<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Pronunciation</title>

<style>
body {
  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  margin: 10px;
  color: #111;
}

#word {
  font-size: 28px;
  text-align: center;
  margin-bottom: 8px;
}

#controls {
  text-align: center;
  margin-bottom: 6px;
}

#status {
  text-align: center;
  margin: 6px 0;
  font-size: 14px;
}

#phonemes {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  gap: 4px;
  margin-top: 14px;
}

/* å•ä¸ªéŸ³ç´ æ¡ */
.phoneme {
  width: 24px;              /* æ¯”ä¹‹å‰çª„çº¦ 30% */
  height: 140px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  cursor: pointer;
  user-select: none;
}

/* é¡¶éƒ¨ï¼šå•è¯åˆ‡å‰²ç‰‡æ®µ */
.ph-letters {
  font-size: 11px;
  line-height: 1;
  margin-bottom: 2px;
}

/* éŸ³ç´ åˆ†æ•° */
.ph-score {
  font-size: 11px;
  font-weight: 600;
  margin-bottom: 2px;
}

/* æŸ±çŠ¶æ¡å®¹å™¨ï¼ˆå›ºå®šé«˜åº¦ï¼Œåº•éƒ¨å¯¹é½ï¼‰ */
.ph-bar-wrap {
  height: 70px;
  width: 100%;
  display: flex;
  align-items: flex-end;
  margin-bottom: 4px;
}

/* æŸ±çŠ¶æ¡æœ¬ä½“ */
.ph-bar {
  width: 100%;
  border-radius: 3px 3px 0 0;
  background: #3b82f6;
}

/* IPA */
.ph-ipa {
  font-size: 13px;
  margin-top: 2px;
}

/* å¼±è¯»éŸ³ç´ ï¼ˆè‡ªåŠ¨é™æƒæ˜¾ç¤ºï¼‰ */
.ph-weak .ph-bar {
  background: #cbd5e1;
}
.ph-weak {
  color: #6b7280;
}
</style>
</head>

<body>

<div id="word">{{Word}}</div>

<div id="controls">
  <button id="rec">ğŸ™ å½•éŸ³</button>
  <button id="stop">â¹ åœæ­¢å¹¶è¯„æµ‹</button>
</div>

<div id="status"></div>

<div id="phonemes"></div>

<script>
let audioCtx, processor, input;
let chunks = [];

const recBtn = document.getElementById("rec");
const stopBtn = document.getElementById("stop");
const status = document.getElementById("status");
const phonemeBox = document.getElementById("phonemes");

recBtn.onclick = async () => {
  chunks = [];
  audioCtx = new AudioContext({ sampleRate: 16000 });
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  input = audioCtx.createMediaStreamSource(stream);
  processor = audioCtx.createScriptProcessor(4096, 1, 1);

  processor.onaudioprocess = e => {
    chunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
  };

  input.connect(processor);
  processor.connect(audioCtx.destination);
  status.innerText = "ğŸ™ å½•éŸ³ä¸­...";
};

stopBtn.onclick = async () => {
  processor.disconnect();
  input.disconnect();

  let len = chunks.reduce((a, b) => a + b.length, 0);
  let data = new Float32Array(len);
  let off = 0;
  chunks.forEach(c => {
    data.set(c, off);
    off += c.length;
  });

  // è£æ‰å‰ç½®é™éŸ³
  let start = 0;
  while (start < data.length && Math.abs(data[start]) < 0.02) start++;
  data = data.slice(start);

  const wav = floatToWav(data, 16000);
  const blob = new Blob([wav], { type: "audio/wav" });

  status.innerText = "â³ è¯„æµ‹ä¸­...";
  phonemeBox.innerHTML = "";

  const fd = new FormData();
  fd.append("audio", blob);
  fd.append("word", document.getElementById("word").innerText.trim());

  const r = await fetch("/assess", { method: "POST", body: fd });
  const j = await r.json();

  if (!j.phonemes || j.phonemes.length === 0) {
    status.innerText = "âš ï¸ æœªè¿”å›éŸ³ç´ æ•°æ®";
    return;
  }

  status.innerText = "å‘éŸ³åˆ†æ•°ï¼š" + j.score;
  renderPhonemes(j.phonemes);
};

function renderPhonemes(list) {
  phonemeBox.innerHTML = "";

  list.forEach(p => {
    const score = Math.round(p.score || 0);
    const h = Math.max(6, score * 0.6); // æ˜ å°„åˆ°æŸ±é«˜
    const weak = score < 60;

    const el = document.createElement("div");
    el.className = "phoneme" + (weak ? " ph-weak" : "");

    el.innerHTML = `
      <div class="ph-letters">${p.letters || ""}</div>
      <div class="ph-score">${score}</div>
      <div class="ph-bar-wrap">
        <div class="ph-bar" style="height:${h}px"></div>
      </div>
      <div class="ph-ipa">${p.ipa}</div>
    `;

    el.onclick = () => {
      const a = new Audio("/audio_phoneme/" + p.ipa + ".mp3");
      a.play();
    };

    phonemeBox.appendChild(el);
  });
}

function floatToWav(float32, sampleRate) {
  const pcm16 = new Int16Array(float32.length);
  for (let i = 0; i < float32.length; i++) {
    pcm16[i] = Math.max(-1, Math.min(1, float32[i])) * 0x7fff;
  }

  const buffer = new ArrayBuffer(44 + pcm16.length * 2);
  const view = new DataView(buffer);

  write(view, 0, "RIFF");
  view.setUint32(4, 36 + pcm16.length * 2, true);
  write(view, 8, "WAVE");
  write(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  write(view, 36, "data");
  view.setUint32(40, pcm16.length * 2, true);

  let p = 44;
  pcm16.forEach(s => {
    view.setInt16(p, s, true);
    p += 2;
  });

  return buffer;
}

function write(v, o, s) {
  for (let i = 0; i < s.length; i++) {
    v.setUint8(o + i, s.charCodeAt(i));
  }
}
</script>

</body>
</html>
